{-
  This test contract serves two main purposes:
  1. It allows testing of non-getter functions in FunC without requiring specific opcodes for each function.
  2. It provides access to internal functions through wrapper getter functions.

  This approach is common in FunC development, where a separate test contract is used for unit testing.
  It enables more comprehensive testing of the contract's functionality, including internal operations
  that are not directly accessible through standard getter methods.
-}
{-
  The only difference from the Main.fc is that it uses patched Pyth functions,
  which don't verify prices sources and allow to run tests with locally generated prices.
-}
#include "imports/stdlib.fc";
#include "tests/PythNoCheck.fc";
#include "Wormhole.fc";
#include "common/op.fc";

() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    ;; Get sender address from message
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);  ;; load flags
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();  ;; load sender address

    int op = in_msg_body~load_uint(32);
    cell data = in_msg_body~load_ref();
    slice data_slice = data.begin_parse();

    if (op == OP_UPDATE_GUARDIAN_SET) {
        update_guardian_set(data_slice);
    } elseif (op == OP_UPDATE_PRICE_FEEDS) {
        update_price_feeds(msg_value, data_slice);
    } elseif (op == OP_EXECUTE_GOVERNANCE_ACTION) {
        execute_governance_action(data_slice);
    } elseif (op == OP_UPGRADE_CONTRACT) {
        execute_upgrade_contract(data);
    } elseif (op == OP_PARSE_PRICE_FEED_UPDATES) {
        cell price_ids_cell = in_msg_body~load_ref();
        slice price_ids_slice = price_ids_cell.begin_parse();
        int min_publish_time = in_msg_body~load_uint(64);
        int max_publish_time = in_msg_body~load_uint(64);
        slice target_address = in_msg_body~load_msg_addr();
        cell custom_payload_cell = in_msg_body~load_ref();
        slice custom_payload = custom_payload_cell.begin_parse();
        parse_price_feed_updates(msg_value, data_slice, price_ids_slice, min_publish_time, max_publish_time, sender_address, target_address, custom_payload);
    } elseif (op == OP_PARSE_UNIQUE_PRICE_FEED_UPDATES) {
        cell price_ids_cell = in_msg_body~load_ref();
        slice price_ids_slice = price_ids_cell.begin_parse();
        int publish_time = in_msg_body~load_uint(64);
        int max_staleness = in_msg_body~load_uint(64);
        slice target_address = in_msg_body~load_msg_addr();
        cell custom_payload_cell = in_msg_body~load_ref();
        slice custom_payload = custom_payload_cell.begin_parse();
        parse_unique_price_feed_updates(msg_value, data_slice, price_ids_slice, publish_time, max_staleness, sender_address, target_address, custom_payload);
    } else {
        throw(0xffff); ;; Throw exception for unknown op
    }
}
