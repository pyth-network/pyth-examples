;; #include "onchain_getter_operation.fc";
#include "../configuration.fc";
#include "../constants/logs.fc";
#include "../imports/stdlib.fc";
#include "tx-utils.fc";

;; this function only required for onchain-getter type operation
() request_price_feed(
    slice response_address,
    int publish_gap,
    int max_staleness,
    cell price_update_data, ;; pyth price update data
    cell pyth_price_ids, ;; required pyth price ids
    cell custom_payload;; custom payload to forward from pyth
) impure {
    (slice pyth_address, _) = load_configuration();

    ;; create message to pyth contract according to schema
    int min_publish_time = now() - publish_gap;
    int max_publish_time = now() + max_staleness;

    cell msg = begin_cell()
        .store_uint(0x18, 6)                                        ;; nobounce
        .store_slice(pyth_address)                                      ;; pyth contract address
        .store_coins(0)                                                 ;; forward amount will be filled automatically (mode 64
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)                 ;; default message headers
        .store_uint(OP::PYTH_PARSE_PRICE_FEED_UPDATES, 32)          ;; pyth opcode
        .store_ref(price_update_data)                                   ;; update data
        .store_ref(pyth_price_ids)                                      ;; price feed IDs
        .store_uint(min_publish_time, 64)                           ;; min_publish_time
        .store_uint(max_publish_time, 64)                           ;; max_publush_time
        .store_slice(response_address)                                  ;; target address (this contract)
        .store_ref(custom_payload)                                      ;; custom payload with recipient and amount
        .end_cell();

    send_raw_message(msg, SENDMODE::CARRY_ALL_REMAINING_MESSAGE_VALUE);
}

(int, cell, slice, cell) parse_price_feed_updates_response(slice response) impure {
    int num_price_feeds = response~load_uint(8); ;; can be ignored
    cell price_feeds_cell = response~load_ref();
    slice initial_sender = response~load_msg_addr();
    cell custom_payload = response~load_ref();
    response.end_parse();

    return (num_price_feeds, price_feeds_cell, initial_sender, custom_payload);
}

(int, int, cell) parse_custom_payload(cell custom_payload) impure {
    slice s = custom_payload.begin_parse();

    int op_code = s~load_op();
    int query_id = s~load_query_id();
    cell external_custom_payload = s~load_ref();

    s.end_parse();

    return (op_code, query_id, external_custom_payload);
}

(int, int, cell) parse_pyth_response_error(slice s) impure {
    int error_code = s~load_uint(32);
    int operation_code = s~load_uint(32);
    cell custom_payload = s~load_ref();
    s.end_parse();
    return (error_code, operation_code, custom_payload);
}

(int, int, cell) parse_operation_payload(cell payload) impure {
    slice s = payload.begin_parse();
    int op_code = s~load_op();
    int query_id = s~load_query_id();
    cell operation_payload = s~load_ref();

    return (op_code, query_id, operation_payload);
}