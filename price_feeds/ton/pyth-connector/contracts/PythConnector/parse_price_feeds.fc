#include "constants/constants.fc";
#include "constants/errors.fc";
#include "imports/stdlib.fc";
#include "utils/common.fc";

;; pack internal price data into a new slice
;; arguments:
;;      internal_price: internal price value
;;      timestamp: price timestamp
;; reurns a new slice containing serialized arguments
(slice) pack_prices_slice(int internal_price, int timestamp) impure inline {
    return
    begin_cell()
        .store_uint(internal_price, 64)
        .store_uint(timestamp, 64)
        .end_cell().begin_parse();
}

;; find and unpack item of pyth_feeds=>internal_asset_ids map
;; arguments:
;;      ids_map: the map to be looked through
;;      pyth_feed_id: specified pyth feed id
;; returns:
;;      internal_id: internal assset id
;;      pyth_referred_feed_id: referred pyth feed id if provided, 0 (256 bit) otherwise
(int, int) unpack_price_map_item(cell ids_map, int pyth_feed_id) impure {
    (slice ids_map_item_slice, int found?) = ids_map.udict_get?(256, pyth_feed_id);
    throw_unless(ERROR::UNSUPPORTED_PRICE_ID, found?);

    int pyth_referred_feed_id = 0;
    int internal_id = ids_map_item_slice~load_uint(256); ;; todo check : move to unpack
    if (ids_map_item_slice.slice_bits() > 0) {
        pyth_referred_feed_id = ids_map_item_slice~load_uint(256);
    }
    ids_map_item_slice.end_parse();

    return (internal_id, pyth_referred_feed_id);
}

;; parse pyth price data
;; arguments:
;;      price_feeds_cell: data cell received from pyth
;; returns:
;;      pyth_feeds_dict: dict: pyth_feed_id=>feed_data
;;      pyth_ids_tuple: tuple of pyth feeds in the dict
(cell, tuple) parse_pyth_price_data(cell price_feeds_cell) impure {
    cell pyth_feeds_dict = new_dict();
    tuple pyth_ids_tuple = empty_tuple();

    while (~ null?(price_feeds_cell)) {
        slice price_feeds_slice = price_feeds_cell.begin_parse();
        int pyth_price_feed_id = price_feeds_slice~load_uint(256);
        cell price_data = price_feeds_slice~load_ref();
        slice price_data_slice = price_data.begin_parse();
        cell current_price_cell = price_data_slice~load_ref();

        pyth_feeds_dict~udict_set(256, pyth_price_feed_id, current_price_cell.begin_parse());
        pyth_ids_tuple~tpush(pyth_price_feed_id);

        if (price_feeds_slice.slice_refs_empty?()) {
            price_feeds_cell = null();
        } else {
            price_feeds_cell = price_feeds_slice~load_ref();
        }
    }

    return (pyth_feeds_dict, pyth_ids_tuple);
}

;; parse pyth data item slice
;; returns:
;;      found?: flag - true if specified feed is found, false otherwise
;;      price: pyth price value
;;      conf: conf
;;      scale:: price scale value
;;      timestamp: price timestamp
(int, int, int, int, int) unpack_pyth_data_item(cell pyth_feeds_dict, int pyth_feed) impure {
    (slice current_price_slice, int found?) = pyth_feeds_dict.udict_get?(256, pyth_feed);
    if (~ found?) {
        return (0, 0, 0, 0, 0);
    }

    int price = current_price_slice~load_int(64);
    int conf = current_price_slice~load_uint(64);
    int expo = current_price_slice~load_int(32);
    int timestamp = current_price_slice~load_uint(64);
    int scale = fast_dec_pow(0 - expo);
    current_price_slice.end_parse();

    return (found?, price, conf, scale, timestamp);
}

;; calculate referred() price based on original assset price and referred
int calculate_referred_price(int price_original, int scale_original, int price_referred, int scale_referred) impure inline {
    return price_referred * CONST::INTERNAL_PRICE_SCALE / scale_referred * price_original / scale_original;
}

;; calculate internal asset price based on pyth feed id
;; arguments:
;;      pyth_feeds_dict: dict: pyth_feed_id => pyth_feed_data
;;      pyth_original_id: specified pyth feed_id
;;      ids_map: map(dict): pyth_feed_id => [internal_asset_id, referred_pyth_id | 0]
(int, int, int) calculate_internal_price(cell pyth_feeds_dict, int pyth_original_id, cell ids_map) impure {
    (int found_original?, int price_original, _, int scale_original, int timestamp_original) = pyth_feeds_dict.unpack_pyth_data_item(pyth_original_id);
    ;; throw_unless(error::price_not_actual, check_price_actual(timestamp_original));

    throw_unless(ERROR::NOT_SAVED_PRICE_ID, found_original?);

    (int internal_id, int pyth_referred_id) = ids_map.unpack_price_map_item(pyth_original_id);
    if (~ pyth_referred_id) {
        int internal_price = muldiv(price_original, CONST::INTERNAL_PRICE_SCALE, scale_original); ;; todo: maybe use muldivr/muldivc?
        return (internal_id, internal_price, timestamp_original);
    }

    (int found_referred?, int price_referred, _, int scale_referred, int timestamp_referred) = pyth_feeds_dict.unpack_pyth_data_item(pyth_referred_id);
    throw_unless(ERROR::REFERRED_PRICE_ID_NOT_FOUND, found_referred?);
    int timestamp = min(timestamp_original, timestamp_referred);
    int internal_price = calculate_referred_price(price_original, scale_original, price_referred, scale_referred);

    return (internal_id, internal_price, timestamp);
}

;; Parse pyth prices feeds and translate it to internal asset_id => internal_price dict
(cell, int) parse_price_feeds(cell price_feeds_cell, cell ids_map) impure {
    cell prices_dict = new_dict();

    ;; we need to parse all data first, to have ability to access any item later,
    ;; because some of them require other arbitrary items
    (cell pyth_feeds_dict, tuple pyth_ids_tuple) = parse_pyth_price_data(price_feeds_cell);

    int count = 0;
    while (count < pyth_ids_tuple.tlen()) {
        int pyth_original_id = pyth_ids_tuple.at(count);
        count += 1;
        (int internal_id, int internal_price, int timestamp) = pyth_feeds_dict.calculate_internal_price(pyth_original_id, ids_map);
        prices_dict~udict_set(256, internal_id, pack_prices_slice(internal_price, timestamp));
    }

    return (prices_dict, pyth_ids_tuple.tlen());
}
