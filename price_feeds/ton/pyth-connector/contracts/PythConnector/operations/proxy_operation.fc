#include "../constants/constants.fc";
#include "../constants/errors.fc";
#include "../constants/logs.fc";
#include "../constants/op_codes.fc";
#include "../imports/stdlib.fc";
#include "../utils/tx-utils.fc";

(int) parse_proxy_operation_payload(cell operation_payload) impure inline {
    slice s = operation_payload.begin_parse();

    int transferred_amount = s~load_uint(64);
    s.end_parse();

    return (transferred_amount);
}

() proxy_operation_process(int my_balance, int msg_value, slice initial_sender, cell prices_dict, int query_id, cell operation_payload) impure {
    var (transferred_amount) = parse_proxy_operation_payload(operation_payload);

    ;; check that the msg value is enough to cover the transferred amount and supply margin, 
    ;; which is supposed to be pyth connector fee
    throw_unless(ERROR::NOT_ENOUGH_TRANSFERRED, msg_value >= transferred_amount + FEE::SUPPLY_MARGIN);
    
    ;; reserve the transferred amount
    raw_reserve(transferred_amount, RESERVE::APPEND_BALANCE);

    emit_log(LOG::PROXY_OPERATION_PROCESSING,
        begin_cell()
            .store_query_id(query_id)
            .store_op(OP::CONNECTOR_PROXY_OPERATION)
            .store_ref(prices_dict)
            .end_cell()
    );

    send_message(
        initial_sender, 0,
        begin_cell().store_query_id(query_id).store_ref(makeTextBody("Thank you!")).end_cell(),
        SENDMODE::CARRY_ALL_BALANCE ;; only balance remaining after reserve is sent to the initial sender
    );
}
