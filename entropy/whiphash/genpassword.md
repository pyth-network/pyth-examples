This MD file tells you how to generate a strong password.

1. Generate device secret (C)

C = crypto.getRandomValues(32). Keep C in secure local storage (or only in memory).

Do not store C in the cloud or anywhere else.


2. Fetch & verify on-chain randomness R1

Request R1 from the generated random number from pyth( two numbers will be generated by pyth, take first one as R1)

Store txid/proof as metadata (public).

3. Mix/extract R1 + C → local_raw (HKDF)

local_raw = HKDF-SHA256( IKM = R1 || C || context, salt = app_salt1, info="local_raw_v1" ) (32 bytes).

HKDF normalizes inputs and gives a uniform seed for hardening.

4. Harden local_raw → LocalKey (Argon2id)

salt1 = randomBytes(16); LocalKey = Argon2id(local_raw, salt1, mem,time,parallel) (outlen 32).

Store salt1 + Argon2 params in metadata; never store LocalKey plaintext.

5. Fetch & verify second on-chain randomness R2

Get R2 from the generated random number from pyth ( two numbers will be generated by pyth, take second one as R2)

6. Derive seed and final harden → Password_bytes

seed_raw = HKDF-SHA256( IKM = LocalKey || R2 || context2, salt = app_salt2, info="seed_v1" )

password_salt = randomBytes(16); Password_bytes = Argon2id(seed_raw, password_salt, mem,time,parallel)

This final Argon2 step defends against offline brute force if backups leak.